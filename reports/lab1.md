# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：


《你交流的对象说明》：


> 我没有与其他人分享代码，没有交流对象


2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：


《你参考的资料说明》：


> 在开始rcore支线之前，曾参加过ysyx，部分内容在此之前依靠了[PA4-1-RTT](https://ysyx.oscc.cc/docs/ics-pa/4.1.html)的内容进行理解


3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。


4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

# 实验报告

## 功能总结

在TCB中加入了`syscall_times`与第一次调度的时间`begin_time`，此后获取TaskInfo的时候只要使用`get_time_ms`减去第一次调度的时间就可以得到需要的结果

## 简答作业

1. 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 三个 bad 测例 (ch2b_bad_\*.rs) ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。

> [rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0
>
> 触发Trap，Unsupported trap {:?}, stval = {:#x}!

2. 深入理解 trap.S 中两个函数 __alltraps 和 __\restore 的作用，并回答如下问题:


2.1. L40：刚进入 __\restore 时，a0 代表了什么值。请指出 __\restore 的两种使用情景。
> goto_restore会将TaskContext作为返回值，其中上下文的ra（返回地址）是__\restore，此时a0是TaskContext\*，可以在任务switch的时候恢复上下文，也可在转换特权级的时候恢复上下文


2.2. L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。
> sstatus，sepc，sscratch，分别是内核态进入用户态前的状态，内核态当前执行到的PC，临时数据（后面代码知是为了交换sp），在再次进入内核态（监管模式S-Mode）的时候会分别被Trap，pc，sp（内核上下文）加载识别分发。


2.3. L50-L56：为何跳过了 x2 和 x4？
> x2(sp)，x4(tp，后续才用)，x2指向当前上下文位置，在恢复的时候会使用sscratch恢复，所以不用保存sp到栈上，之后也不需要通过栈来恢复sp（恢复的时候由于调度任务策略，sp会由操作系统指定，而非栈上的gpr[2]）。tp同样由操作系统控制恢复。


2.4. L60：该指令之后，sp 和 sscratch 中的值分别有什么意义？
> sp此时指向用户栈，sscratch保存了内核态的栈指针，之后sret恢复用户态，此后如若U syscall S，则csrw sp, sscratch再次交换以切换U-\>S。


2.5. __\restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？
> 由于2.4.的交换指令，sp此时指向用户态栈指针，转台切换在sret，pc = CSRs[sepc], mode = CSRs[sstatus].SPP, CSRs[sstatus].SIE=CSRs[sstatus].SPIE，~.SPIE=1，~.SPP=0（来源于蒙娜丽莎书：RISC-V开放架构设计之道）


2.6. L13：该指令之后，sp 和 sscratch 中的值分别有什么意义？
> 同2.4. `如若U syscall S，则csrw sp, sscratch再次交换以切换U-\>S`，此时sp指向内核栈，sscratch指向用户栈


2.7. 从 U 态进入 S 态是哪一条指令发生的？
> syscall asm! "ecall"

